# Milestone 3 Short-answer questions

## Exercise 5
The main difference between compile-m2 and compile-m3 is that we use graph-colouring register allocation in compile-m3. In m2, we do not use conflict-analysis so every abstract location is forever in conflict with every other abstract location. This means we are inefficiently utilizing our fast registers, and instead our abstract locations spill to the slower frame variables. By introducing conflict-analysis in m3, we reduce the number of conflicts and increase the number of variables that can fit into registers. Meaning the code generated by compile-m3 should run faster. However, the actual compile time should be faster for compile-m2. This is because m3’s graph-colouring register allocation pass is quadratic and dominates compile time. Because of Rice’s Theorem, we cannot say that compile-m3 is strictly “better” than compile-m2. However, we can say that compile-m3 has an advantage over compile-m2 when it comes to efficient register allocation and generating code that runs faster. On the other hand, compile-m2 is simpler and requires less compile time. Surprisingly, given the same input, compile-m2 actually generated faster code than compile-m3.

M2: 
"/var/tmp/16768786961676878696208.exe"
time (for i in {1..1000}; do ./16768786961676878696208.exe; done)
real    0m1.979s
user    0m0.955s
sys     0m1.105s

M3: 
"/var/tmp/16768787131676878713312.exe"
time (for i in {1..1000}; do ./16768787131676878713312.exe; done)
real    0m2.198s
user    0m0.975s
sys     0m1.305s